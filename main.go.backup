package main

// imports now include
import (
	"encoding/csv"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	apps "k8s.io/api/apps/v1"
	batch "k8s.io/api/batch/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	_ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
	"k8s.io/client-go/tools/clientcmd"
)

// Attribute represent a k8s attribute
type Attribute struct {
	Name      string
	Value     interface{}
	Flagged   bool
	Default   bool
	Set       bool
	Reason    string
	Container string
}

// Record represents a K8s object and all it's attributes
type Record struct {
	Cluster    string
	Ns         string
	Kind       string
	KindName   string
	ObjFlagged bool
	Attributes []Attribute
	Global     map[string]interface{}
}

// Global Variables
var cs *kubernetes.Clientset
var rawData []Record

// main function
func main() {

	// FFU - if we want to limit the report to a specific namespace
	var fNamespace string

	// connect to k8s
	connect(fNamespace)

	// all namespaces
	log.Printf("Getting Namespaces")
	namespaces, err := cs.CoreV1().Namespaces().List(metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get namespaces:", err)
	}

	for i, ns := range namespaces.Items {
		fmt.Printf("Working on Namespace [%d] - [%s]\n", i, ns.GetName())

		analyzeNS(ns)
	}

	createCSVReport("apolicy.k8s.report")
}

// Connect to K8s
func connect(fNamespace string) {
	flag.StringVar(&fNamespace, "namespace", "", "namespace")

	// Bootstrap k8s configuration from local 	Kubernetes config file
	kubeconfig := filepath.Join(os.Getenv("HOME"), ".kube", "config")
	log.Println("Using kubeconfig file: ", kubeconfig)
	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		log.Fatal(err)
	}

	// Create an rest client not targeting specific API version
	cs, err = kubernetes.NewForConfig(config)
	if err != nil {
		log.Println("Failed to connect to kubernetes. See ERROR")
		log.Fatal(err)
		os.Exit(1)
	}
}

// analyze namespace details
func analyzeNS(ns v1.Namespace) {
	// Get all deployments
	deployments, err := cs.AppsV1().Deployments(ns.GetName()).List(metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get deployments:", err)
	}

	for i, deployment := range deployments.Items {
		fmt.Printf("Working on Deployment [%d] - [%s]\n", i, deployment.GetName())

		analyzeDep(deployment)
	}

	// Get all DaemonSets
	daemonSets, err := cs.AppsV1().DaemonSets(ns.GetName()).List(metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get daemonsets:", err)
	}

	for i, ds := range daemonSets.Items {
		fmt.Printf("Working on DaemonSet [%d] - [%s]\n", i, ds.GetName())

		analyzeDS(ds)
	}

	statefulSets, err := cs.AppsV1().StatefulSets(ns.GetName()).List(metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get statefulsets:", err)
	}

	for i, ss := range statefulSets.Items {
		fmt.Printf("Working on StatefulSet [%d] - [%s]\n", i, ss.GetName())

		analyzeSS(ss)
	}

	/* Need to handle replicaSets differently
	replicaSets, err := cs.AppsV1().ReplicaSets(ns.GetName()).List(metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get replicasets:", err)
	}

	for i, rs := range replicaSets.Items {
		fmt.Printf("Working on ReplicaSet [%d] - [%s]\n", i, rs.GetName())

		analyzeRS(rs)
	}
	*/

	jobs, err := cs.BatchV1().Jobs(ns.GetName()).List(metav1.ListOptions{})
	if err != nil {
		log.Fatalln("failed to get jobs:", err)
	}

	for i, job := range jobs.Items {
		fmt.Printf("Working on ReplicaSet [%d] - [%s]\n", i, job.GetName())

		analyzeJob(job)
	}

	/*
		// get all JOBS
		// get all replicaSets
				replicaSets, err := clientset.AppsV1().ReplicaSets(ns.GetNamespace()).List(metav1.ListOptions{})
				if err != nil {
					log.Fatalln("failed to get replicasets:", err)
				}
				fmt.Println(replicaSets)

				statefulSets, err := clientset.AppsV1().StatefulSets(ns.GetNamespace()).List(metav1.ListOptions{})
				if err != nil {
					log.Fatalln("failed to get statefulsets:", err)
				}
				fmt.Println(statefulSets)
	*/
}

func analyzeJob(j batch.Job) {
	log.Printf("Analyzing Job [%s]", j.GetName())

	jData := Record{
		Cluster:    j.GetClusterName(),
		Ns:         j.GetNamespace(),
		Kind:       "Job",
		KindName:   j.GetName(),
		ObjFlagged: false,
	}

	podSpec := j.Spec.Template.Spec

	analyzePodSpec(podSpec, &jData)

	for _, container := range podSpec.Containers {

		analyzeContainerPodSpec(container, &jData)
	}

	rawData = append(rawData, jData)

}

func analyzeRS(rs apps.ReplicaSet) {
	log.Printf("Analyzing ReplicaSet [%s]", rs.GetName())

	rsData := Record{
		Cluster:    rs.GetClusterName(),
		Ns:         rs.GetNamespace(),
		Kind:       "ReplicaSet",
		KindName:   rs.GetName(),
		ObjFlagged: false,
	}

	podSpec := rs.Spec.Template.Spec

	analyzePodSpec(podSpec, &rsData)

	for _, container := range podSpec.Containers {

		analyzeContainerPodSpec(container, &rsData)
	}

	rawData = append(rawData, rsData)

}

func analyzeSS(ss apps.StatefulSet) {
	log.Printf("Analyzing StatefulSet [%s]", ss.GetName())

	ssData := Record{
		Cluster:    ss.GetClusterName(),
		Ns:         ss.GetNamespace(),
		Kind:       "StatefulSet",
		KindName:   ss.GetName(),
		ObjFlagged: false,
	}

	podSpec := ss.Spec.Template.Spec

	analyzePodSpec(podSpec, &ssData)

	for _, container := range podSpec.Containers {

		analyzeContainerPodSpec(container, &ssData)
	}

	rawData = append(rawData, ssData)

}

func analyzeDS(ds apps.DaemonSet) {
	log.Printf("Analyzing DaemonSet [%s]", ds.GetName())

	dsData := Record{
		Cluster:    ds.GetClusterName(),
		Ns:         ds.GetNamespace(),
		Kind:       "DaemonSet",
		KindName:   ds.GetName(),
		ObjFlagged: false,
	}

	podSpec := ds.Spec.Template.Spec

	analyzePodSpec(podSpec, &dsData)

	for _, container := range podSpec.Containers {

		analyzeContainerPodSpec(container, &dsData)
	}

	rawData = append(rawData, dsData)

}

// Get the deployment attributes and analyze them
func analyzeDep(deployment apps.Deployment) {
	log.Printf("Analyzing Deployment [%s]", deployment.GetName())

	depData := Record{
		Cluster:    deployment.GetClusterName(),
		Ns:         deployment.GetNamespace(),
		Kind:       "Deployment",
		KindName:   deployment.GetName(),
		ObjFlagged: false,
	}

	podSepc := deployment.Spec.Template.Spec

	analyzePodSpec(podSepc, &depData)

	for _, container := range podSepc.Containers {

		analyzeContainerPodSpec(container, &depData)
	}

	// TODO: get all matching labels and expressions - not sure how to use it in our analysis currently.

	rawData = append(rawData, depData)
}

func createCSVReport(reportName string) {
	csvFile, err := os.Create(reportName + ".csv")

	if err != nil {
		log.Fatalf("Failed creating file: %s", err)
		log.Println("File cannot be created for report")
		os.Exit(2)
	}

	var recs [][]string

	// write headers to the report
	csvWriter := csv.NewWriter(csvFile)

	header := []string{
		"Cluster Name",
		"Namespace Name",
		"Workload Kind",
		"Workload Name",
		"Workload flagged",
		"Container Name",
		"Attribute Name",
		"Attribute Value",
		"Is Defaulted",
		"Is Set",
		"Is Flagged",
	}

	recs = append(recs, header)

	// preparing data for writing to csv
	for _, r := range rawData {
		for _, a := range r.Attributes {
			attr := []string{
				r.Cluster,
				r.Ns,
				r.Kind,
				r.KindName,
				strconv.FormatBool(r.ObjFlagged),
				a.Container,
				a.Name,
				fmt.Sprintf("%v", a.Value),
				strconv.FormatBool(a.Default),
				strconv.FormatBool(a.Set),
				strconv.FormatBool(a.Flagged),
			}

			fmt.Printf("Type: %T, Value: %v\n", a.Value, a.Value)

			recs = append(recs, attr)
		}
	}

	for _, r := range recs {
		csvWriter.Write(r)
	}
	csvWriter.Flush()
}

// NewAttribute creates new attribute and set defaults
func NewAttribute(name string, value interface{}, container string) *Attribute {
	a := Attribute{
		Name:      name,
		Default:   true,
		Flagged:   false,
		Set:       false,
		Container: container,
	}

	switch value.(type) {
	case (*int64):
		if value != (*int64)(nil) {
			a.Value = *(value.(*int64))
			a.Set = true
			a.Default = false
		}
	case (*bool):
		if value != (*bool)(nil) {
			a.Value = *(value.(*bool))
			a.Set = true
			a.Default = false
		}
	case (bool):
		a.Value = value
		a.Set = true
		a.Default = false
	case (string):
		if value != nil {
			if value != "" {
				a.Value = value
				a.Set = true
				a.Default = false
			}
		}
	default:
		if value != nil {
			a.Value = value
			a.Set = true
			a.Default = false
		}
	}

	return &a
}

// Analyze the Pod Spec and add to the record
func analyzePodSpec(ps v1.PodSpec, r *Record) {

	fmt.Println("Analyzing the Pod Spec")

	{ // get pod template host network access
		pHostNetwork := NewAttribute("Host Network", ps.HostNetwork, "")

		if pHostNetwork.Value == (*bool)(nil) {
			r.ObjFlagged = true
			pHostNetwork.Flagged = true
			pHostNetwork.Reason = "Host (node) network access is [NOT SET]"
		} else {
			pHostNetwork.Set = true
			pHostNetwork.Default = false
			if pHostNetwork.Value == true {
				r.ObjFlagged = true
				pHostNetwork.Flagged = true
				pHostNetwork.Reason = "Host (node) network access is set to [TRUE]"
			}
		}

		// add attribute to record
		r.Attributes = append(r.Attributes, *pHostNetwork)
	}
	{ // get pod template DNS Policy
		pDNS := NewAttribute("DNS Policy", ps.DNSPolicy, "")

		if pDNS.Value == (*string)(nil) {
			r.ObjFlagged = true
			pDNS.Flagged = true
			pDNS.Reason = "DNS Policy [NOT SET]"
		} else {
			pDNS.Set = true
			pDNS.Default = false
		}

		// add attribute to record
		r.Attributes = append(r.Attributes, *pDNS)
	}

	{ // get pod template Run As User
		pRunAsUser := NewAttribute("Run As User", ps.SecurityContext.RunAsUser, "")

		// checking if the Run As User is defined at all
		if pRunAsUser.Value == (*int64)(nil) {
			r.ObjFlagged = true
			pRunAsUser.Flagged = true
			pRunAsUser.Reason = "Run as user is not set"
		} else {
			// set the actual value to the value attribute
			pRunAsUser.Value = pRunAsUser.Value.(*int64)
			r.Global["Run As User"] = pRunAsUser.Value
			pRunAsUser.Set = true
			pRunAsUser.Default = false

			if pRunAsUser.Value == 0 { // checking if the defined user is root (move to analysis stage?)
				r.ObjFlagged = true
				pRunAsUser.Flagged = true
				pRunAsUser.Reason = "Run as user is set to ROOT"
			}

		}

		// add attribute to record
		r.Attributes = append(r.Attributes, *pRunAsUser)
	}

	{ // get pod template Must Run As NON Root
		pNonRoot := NewAttribute("Run As Non Root", ps.SecurityContext.RunAsNonRoot, "")

		if pNonRoot.Value == (*bool)(nil) {
			r.ObjFlagged = true
			pNonRoot.Flagged = true
			pNonRoot.Reason = "Run as non root is not set"
		} else {
			r.Global["Run As Non Root"] = pNonRoot.Value
			pNonRoot.Set = true
			pNonRoot.Default = false
			if pNonRoot.Value == false {
				r.ObjFlagged = true
				pNonRoot.Flagged = true
				pNonRoot.Reason = "Run as non root is set to FALSE"
			}
		}

		// add attribute to recorda
		r.Attributes = append(r.Attributes, *pNonRoot)
	}

	{ // get pod spec Run As Group
		pRunAsGroup := NewAttribute("Run As Group", ps.SecurityContext.RunAsGroup, "")

		if pRunAsGroup.Value == (*int64)(nil) {
			r.ObjFlagged = true
			pRunAsGroup.Flagged = true
			pRunAsGroup.Reason = "Run as group is not set"
		} else {
			r.Global["Run As Group"] = pRunAsGroup.Value
			pRunAsGroup.Set = true
			pRunAsGroup.Default = false
			if pRunAsGroup.Value == 0 {
				r.ObjFlagged = true
				pRunAsGroup.Flagged = true
				pRunAsGroup.Reason = "Run as group is set to ROOT group"
			}
		}

		// add attribute to record
		r.Attributes = append(r.Attributes, *pRunAsGroup)
	}

	{ // get pod spec Service Account Name for the Pod
		pSA := NewAttribute("POD ServiceAccount", ps.ServiceAccountName, "")

		if pSA.Value == (*string)(nil) || pSA.Value == "" {
			r.ObjFlagged = true
			pSA.Flagged = true
			pSA.Reason = "POD default service account is not set. Defaults to [default]"
		} else if pSA.Value == "default" {
			r.ObjFlagged = true
			pSA.Flagged = true
			pSA.Set = true
			pSA.Default = false
			pSA.Reason = "POD default service account is set to [default]"
		} else {
			pSA.Set = true
			pSA.Default = false
		}

		// add attribute to record
		r.Attributes = append(r.Attributes, *pSA)
	}

	fmt.Println("Done analyzing the Pod Spec")
}

func analyzeContainerPodSpec(c v1.Container, r *Record) {
	fmt.Println("Analyzing the Container in Pod Spec")

	fmt.Printf("Working on container [%s]\n", c.Name)

	{ // Image pull policy
		cPullPolicy := NewAttribute("Image Pull Policy", c.ImagePullPolicy, c.Name)

		// [TODO] we should use constants here instead
		if cPullPolicy.Value == (*string)(nil) || cPullPolicy.Value == "" {
			r.ObjFlagged = true
			cPullPolicy.Flagged = true
			cPullPolicy.Reason = "ImagePullPolicy is not set"
		} else {
			// NEVER is bad, IfNotPresent is default
			cPullPolicy.Set = true
			cPullPolicy.Default = false
		}

		// add attribute to record
		r.Attributes = append(r.Attributes, *cPullPolicy)
	}

	{ // Image name check
		cImage := NewAttribute("Image Name", c.Image, c.Name)

		// [TODO] check the image?
		// This is an impossible edge case (doing this just to cover it)
		if cImage.Value == (*string)(nil) || cImage.Value == "" {
			r.ObjFlagged = true
			cImage.Flagged = true
			cImage.Reason = "Image is not set [?!]"
		} else {

			if strings.HasSuffix(strings.ToLower(cImage.Value.(string)), ":latest") {
				r.ObjFlagged = true
				cImage.Flagged = true
				cImage.Set = true
				cImage.Default = false
				cImage.Reason = "Image with [LATEST] tag is not recommended"
			}
		}

		// add attribute to record
		r.Attributes = append(r.Attributes, *cImage)
	}

	if c.SecurityContext != nil {
		{ // Container privileged attribute
			cPriv := NewAttribute("Privileged", c.SecurityContext.Privileged, c.Name)

			if cPriv.Value == (*bool)(nil) {
				r.ObjFlagged = true
				cPriv.Flagged = true
				cPriv.Reason = "Container privileged is not defined & is not limited"
			} else {
				// setting the value to teh deref value
				cPriv.Value = *(cPriv.Value.(*bool))
				cPriv.Set = true
				cPriv.Default = false
				if cPriv.Value == true {
					r.ObjFlagged = true
					cPriv.Flagged = true
					cPriv.Reason = "Container set to allow [PRIVILEGED]"
				}
			}

			// add attribute to record
			r.Attributes = append(r.Attributes, *cPriv)
		}

		{ // Container AllowPrivilegeEscalation attribute
			cAllowPrivEsc := NewAttribute("Allow Privilege Escalation", c.SecurityContext.AllowPrivilegeEscalation, c.Name)

			if cAllowPrivEsc.Value == (*bool)(nil) {
				r.ObjFlagged = true
				cAllowPrivEsc.Flagged = true
				cAllowPrivEsc.Reason = "Container privilege escalation is not defined and defaults to [ALLOW]"
			} else if cAllowPrivEsc.Value == true {
				r.ObjFlagged = true
				cAllowPrivEsc.Flagged = true
				cAllowPrivEsc.Set = true
				cAllowPrivEsc.Default = false
				cAllowPrivEsc.Reason = "Container set to allow [PRIVILEGED]"
			}

			// add attribute to record
			r.Attributes = append(r.Attributes, *cAllowPrivEsc)
		}

		{ // privileged escalation
			cPrivEsc := NewAttribute("Privilege Escalation", c.SecurityContext.AllowPrivilegeEscalation, c.Name)

			if cPrivEsc.Value == (*bool)(nil) {
				r.ObjFlagged = true
				cPrivEsc.Flagged = true
				cPrivEsc.Reason = "Container privileged escalation is not defined & is not limited"
			} else if cPrivEsc.Value == true {
				r.ObjFlagged = true
				cPrivEsc.Flagged = true
				cPrivEsc.Set = true
				cPrivEsc.Default = false
				cPrivEsc.Reason = "Container set to allow [PRIVILEGED ESCALATION]"
			}

			// add attribute to record
			r.Attributes = append(r.Attributes, *cPrivEsc)
		}

		{ // Read only root file system
			cROFS := NewAttribute("Read Only File System", c.SecurityContext.ReadOnlyRootFilesystem, c.Name)

			if cROFS.Value == (*bool)(nil) {
				r.ObjFlagged = true
				cROFS.Flagged = true
				cROFS.Reason = "Container access to root file system is not defined & is not limited"
			} else if cROFS.Value == false {
				r.ObjFlagged = true
				cROFS.Flagged = true
				cROFS.Set = true
				cROFS.Default = false
				cROFS.Reason = "Container access to root file system is [NOT READ ONLY]"
			}

			// add attribute to record
			r.Attributes = append(r.Attributes, *cROFS)
		}

		// ********************************************
		// TAKE CARE OF THE UID vs the DEPLOYMENT LEVEL
		// ********************************************
		{ // Container Run As User
			cRunAsUser := NewAttribute("Container Run As User ", c.SecurityContext.RunAsUser, c.Name)

			if cRunAsUser.Value == (*int64)(nil) {
				r.ObjFlagged = true
				cRunAsUser.Flagged = true
				cRunAsUser.Reason = "Container Run As User is not defined & is not limited"

				// no container level run as user defined, check the workload level.

			} else if cRunAsUser.Value == 0 {
				r.ObjFlagged = true
				cRunAsUser.Flagged = true
				cRunAsUser.Set = true
				cRunAsUser.Default = false
				cRunAsUser.Reason = "Container Run As User is set to [ROOT]"
			}

			// add attribute to record
			r.Attributes = append(r.Attributes, *cRunAsUser)
		}

		{ // Container Run As Group
			cRunAsGroup := NewAttribute("Container Run As Group ", c.SecurityContext.RunAsGroup, c.Name)

			if cRunAsGroup.Value == (*int64)(nil) {
				r.ObjFlagged = true
				cRunAsGroup.Flagged = true
				cRunAsGroup.Reason = "Container Run As Group is not defined & is not limited"

				// no container level run as group defined, check the workload level.

			} else if cRunAsGroup.Value == 0 {
				r.ObjFlagged = true
				cRunAsGroup.Flagged = true
				cRunAsGroup.Set = true
				cRunAsGroup.Default = false
				cRunAsGroup.Reason = "Container Run As Group is set to [ROOT]"
			}

			// add attribute to record
			r.Attributes = append(r.Attributes, *cRunAsGroup)
		}
	}

	fmt.Println("Done analyzing the Container in Pod Spec")
}

// deployment/statefulset/daemonset podspec - all attributes
// podspec - container attributes
// pods all attributes (from runtime)
// containers - all attributes from running
